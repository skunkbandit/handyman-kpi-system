"""\nEnd-to-end integration tests for the installer (part 2).\n\nThis module continues the end-to-end tests with upgrade and side-by-side installation tests.\n"""\n\nimport os\nimport sys\nimport json\nimport pytest\nimport subprocess\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom unittest.mock import patch\n\n# Add the project root to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')))\n\n# Import test utilities\nfrom utils import create_test_configuration\n\n\nclass TestInstallerUpgrades:\n    """End-to-end tests for upgrade and side-by-side installation scenarios."""\n    \n    @pytest.fixture\n    def installation_environment(self, temp_directory):\n        """Create a complete installation environment for testing."""\n        # Create subdirectories for the installation test\n        install_dir = os.path.join(temp_directory, 'kpi_system')\n        os.makedirs(install_dir, exist_ok=True)\n        \n        config_dir = os.path.join(temp_directory, 'config')\n        os.makedirs(config_dir, exist_ok=True)\n        \n        data_dir = os.path.join(temp_directory, 'data')\n        os.makedirs(data_dir, exist_ok=True)\n        \n        # Create a test configuration\n        config_path = os.path.join(config_dir, 'installer_config.json')\n        create_test_configuration(config_path, database_type='sqlite', temp_dir=temp_directory)\n        \n        return {\n            'install_dir': install_dir,\n            'config_dir': config_dir,\n            'data_dir': data_dir,\n            'config_path': config_path,\n            'temp_dir': temp_directory\n        }\n    \n    @pytest.mark.slow\n    def test_upgrade_installation(self, installation_environment):\n        """Test upgrading from a previous version."""\n        install_dir = installation_environment['install_dir']\n        \n        # Create a "previous version" installation\n        app_dir = os.path.join(install_dir, 'app')\n        os.makedirs(app_dir, exist_ok=True)\n        \n        # Create version file for previous version\n        with open(os.path.join(install_dir, 'version.txt'), 'w') as f:\n            f.write('1.0.0')\n        \n        # Create some configuration files\n        config_dir = os.path.join(install_dir, 'config')\n        os.makedirs(config_dir, exist_ok=True)\n        \n        with open(os.path.join(config_dir, 'settings.json'), 'w') as f:\n            json.dump({\n                'app_name': 'Handyman KPI System',\n                'theme': 'light',\n                'language': 'en',\n                'custom_setting': 'value'\n            }, f, indent=4)\n        \n        # Create a mock upgrader\n        class MockUpgrader:\n            def __init__(self, install_dir, new_version):\n                self.install_dir = install_dir\n                self.new_version = new_version\n                self.upgrade_log = []\n            \n            def upgrade(self):\n                # Log upgrade steps\n                self.upgrade_log.append("Starting upgrade")\n                \n                # Check if installation directory exists\n                if not os.path.exists(self.install_dir):\n                    self.upgrade_log.append("Installation directory not found")\n                    return False\n                \n                # Read current version\n                version_file = os.path.join(self.install_dir, 'version.txt')\n                if os.path.exists(version_file):\n                    with open(version_file, 'r') as f:\n                        current_version = f.read().strip()\n                    self.upgrade_log.append(f"Current version: {current_version}")\n                else:\n                    self.upgrade_log.append("Version file not found")\n                    return False\n                \n                # Update version file\n                with open(version_file, 'w') as f:\n                    f.write(self.new_version)\n                self.upgrade_log.append(f"Updated version to: {self.new_version}")\n                \n                # Update application files\n                app_dir = os.path.join(self.install_dir, 'app')\n                \n                # Create new file\n                with open(os.path.join(app_dir, 'new_feature.txt'), 'w') as f:\n                    f.write('New feature added in version 2.0.0')\n                self.upgrade_log.append(f"Added new feature file")\n                \n                # Preserve configuration\n                config_dir = os.path.join(self.install_dir, 'config')\n                if os.path.exists(os.path.join(config_dir, 'settings.json')):\n                    with open(os.path.join(config_dir, 'settings.json'), 'r') as f:\n                        settings = json.load(f)\n                    \n                    # Update settings but preserve custom values\n                    settings['version'] = self.new_version\n                    settings['theme'] = settings.get('theme', 'light')  # Preserve existing theme\n                    \n                    with open(os.path.join(config_dir, 'settings.json'), 'w') as f:\n                        json.dump(settings, f, indent=4)\n                    \n                    self.upgrade_log.append("Updated configuration settings")\n                \n                self.upgrade_log.append("Upgrade completed")\n                return True\n        \n        # Create and run the upgrader\n        upgrader = MockUpgrader(install_dir, '2.0.0')\n        result = upgrader.upgrade()\n        \n        # Verify upgrade was successful\n        assert result, "Upgrade failed"\n        assert "Upgrade completed" in upgrader.upgrade_log\n        \n        # Verify version was updated\n        with open(os.path.join(install_dir, 'version.txt'), 'r') as f:\n            version = f.read().strip()\n        assert version == '2.0.0', "Version not updated"\n        \n        # Verify new feature file was added\n        assert os.path.exists(os.path.join(app_dir, 'new_feature.txt')), "New feature file not added"\n        \n        # Verify configuration was preserved\n        with open(os.path.join(config_dir, 'settings.json'), 'r') as f:\n            settings = json.load(f)\n        assert settings['version'] == '2.0.0', "Version not updated in settings"\n        assert settings['custom_setting'] == 'value', "Custom setting not preserved"\n        assert settings['theme'] == 'light', "Theme not preserved"\n    \n    @pytest.mark.slow\n    def test_side_by_side_installation(self, installation_environment):\n        """Test side-by-side installation of different versions."""\n        base_dir = installation_environment['temp_dir']\n        \n        # Create two separate installation directories\n        v1_dir = os.path.join(base_dir, 'kpi_system_v1')\n        v2_dir = os.path.join(base_dir, 'kpi_system_v2')\n        \n        os.makedirs(v1_dir, exist_ok=True)\n        os.makedirs(v2_dir, exist_ok=True)\n        \n        # Create version files\n        with open(os.path.join(v1_dir, 'version.txt'), 'w') as f:\n            f.write('1.0.0')\n        \n        with open(os.path.join(v2_dir, 'version.txt'), 'w') as f:\n            f.write('2.0.0')\n        \n        # Create app directories\n        v1_app_dir = os.path.join(v1_dir, 'app')\n        v2_app_dir = os.path.join(v2_dir, 'app')\n        \n        os.makedirs(v1_app_dir, exist_ok=True)\n        os.makedirs(v2_app_dir, exist_ok=True)\n        \n        # Create some test files\n        with open(os.path.join(v1_app_dir, 'v1_feature.txt'), 'w') as f:\n            f.write('Feature in version 1.0.0')\n        \n        with open(os.path.join(v2_app_dir, 'v2_feature.txt'), 'w') as f:\n            f.write('Feature in version 2.0.0')\n        \n        # Verify both installations exist with different files\n        assert os.path.exists(v1_dir), "V1 installation directory not created"\n        assert os.path.exists(v2_dir), "V2 installation directory not created"\n        assert os.path.exists(os.path.join(v1_app_dir, 'v1_feature.txt')), "V1 feature file not created"\n        assert os.path.exists(os.path.join(v2_app_dir, 'v2_feature.txt')), "V2 feature file not created"\n        \n        # Verify versions are different\n        with open(os.path.join(v1_dir, 'version.txt'), 'r') as f:\n            v1_version = f.read().strip()\n        \n        with open(os.path.join(v2_dir, 'version.txt'), 'r') as f:\n            v2_version = f.read().strip()\n        \n        assert v1_version == '1.0.0', "V1 version incorrect"\n        assert v2_version == '2.0.0', "V2 version incorrect"\n        assert v1_version != v2_version, "Versions should be different"