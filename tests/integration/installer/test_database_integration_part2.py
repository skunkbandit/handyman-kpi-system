"""\nIntegration tests for database adapters and initializer (part 2).\n\nThis module contains additional database integration tests focusing on\nmigration, configuration validation, and cross-database compatibility.\n"""\n\nimport os\nimport sys\nimport pytest\nimport tempfile\nimport unittest\nimport sqlite3\nfrom contextlib import closing\n\n# Add the project root to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')))\n\n# Import installer modules\nfrom installer.core.config import ConfigManager\nfrom installer.core.database import DatabaseManager\nfrom installer.shared.database.adapters import get_adapter\nfrom installer.shared.database.initializer import DatabaseInitializer\n\n# Import test utils\nfrom utils import (\n    local_mysql_is_available,\n    local_postgresql_is_available,\n    TEST_ADMIN_USER,\n    TEST_EMPLOYEE_DATA,\n    validate_database_schema\n)\n\n\nclass TestDatabaseMigrationAndConfig:\n    """Test database migration and configuration validation."""\n    \n    @pytest.mark.skipif(not local_postgresql_is_available(), reason="PostgreSQL not available")\n    def test_postgresql_integration(self, temp_directory, sample_schema_dir):\n        """Test integration with PostgreSQL database."""\n        # Create database configuration\n        db_config = {\n            'type': 'postgresql',\n            'host': 'localhost',\n            'port': 5432,\n            'user': 'postgres',\n            'password': 'postgres',\n            'database': 'test_handyman'\n        }\n        \n        # Initialize database manager and initializer\n        initializer = DatabaseInitializer(schema_dir=sample_schema_dir)\n        \n        # Test connection\n        status, error = initializer.test_database_connection(db_config)\n        # Skip test if PostgreSQL is not actually available or credentials are wrong\n        if not status and "password authentication failed" in error:\n            pytest.skip(f"PostgreSQL credentials invalid: {error}")\n        assert status, f"Connection test failed: {error}"\n        \n        # Initialize database\n        assert initializer.initialize_database(db_config), "Database initialization failed"\n        \n        # Create admin user\n        assert initializer.create_admin_user(\n            TEST_ADMIN_USER['username'],\n            TEST_ADMIN_USER['password'],\n            TEST_ADMIN_USER['email'],\n            db_config\n        ), "Admin user creation failed"\n        \n        # Get database info\n        info = initializer.get_database_info(db_config)\n        assert info['type'] == 'postgresql'\n        assert info['tables']['users']['row_count'] == 1\n    \n    def test_config_database_integration(self, temp_directory, sample_schema_dir):\n        """Test integration between config manager and database initializer."""\n        # Create paths\n        config_path = os.path.join(temp_directory, 'config.json')\n        db_path = os.path.join(temp_directory, 'test.db')\n        \n        # Create configuration\n        config = {\n            'version': '1.0.0',\n            'app_name': 'Handyman KPI System',\n            'database': {\n                'type': 'sqlite',\n                'path': db_path\n            },\n            'installation_path': os.path.join(temp_directory, 'kpi_system'),\n            'admin_user': {\n                'username': TEST_ADMIN_USER['username'],\n                'email': TEST_ADMIN_USER['email']\n            }\n        }\n        \n        # Initialize config manager and save config\n        config_manager = ConfigManager(config_path)\n        config_manager.save_config(config)\n        \n        # Initialize database manager and initializer\n        db_config = config['database']\n        initializer = DatabaseInitializer(schema_dir=sample_schema_dir)\n        \n        # Test connection\n        status, _ = initializer.test_database_connection(db_config)\n        assert status\n        \n        # Initialize database\n        assert initializer.initialize_database(db_config)\n        \n        # Create admin user using config\n        admin_config = config['admin_user']\n        assert initializer.create_admin_user(\n            admin_config['username'],\n            TEST_ADMIN_USER['password'],\n            admin_config['email'],\n            db_config\n        )\n        \n        # Verify configuration is updated correctly\n        loaded_config = config_manager.load_config()\n        assert loaded_config['database']['type'] == 'sqlite'\n        assert loaded_config['admin_user']['username'] == TEST_ADMIN_USER['username']\n    \n    def test_migration(self, temp_directory, sample_schema_dir):\n        """Test database migration scenarios."""\n        # Create database paths\n        old_db_path = os.path.join(temp_directory, 'old.db')\n        new_db_path = os.path.join(temp_directory, 'new.db')\n        \n        # Create old database with partial schema\n        with closing(sqlite3.connect(old_db_path)) as conn:\n            conn.executescript('''\n                CREATE TABLE users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    password_hash TEXT NOT NULL,\n                    salt TEXT NOT NULL,\n                    email TEXT,\n                    is_admin INTEGER DEFAULT 0\n                );\n                \n                CREATE TABLE skill_tiers (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT UNIQUE NOT NULL,\n                    description TEXT\n                );\n                \n                -- Old schema missing employees and evaluations tables\n                \n                -- Insert sample data\n                INSERT INTO users (username, password_hash, salt, email, is_admin)\n                VALUES ('admin', 'oldhash', 'oldsalt', 'admin@example.com', 1);\n                \n                INSERT INTO skill_tiers (name, description)\n                VALUES \n                    ('Apprentice', 'Entry level worker'),\n                    ('Handyman', 'Basic skills'),\n                    ('Craftsman', 'Experienced technician');\n            ''')\n        \n        # Create new database with full schema\n        with closing(sqlite3.connect(new_db_path)) as conn:\n            conn.executescript('''\n                CREATE TABLE users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    password_hash TEXT NOT NULL,\n                    salt TEXT NOT NULL,\n                    email TEXT,\n                    is_admin INTEGER DEFAULT 0\n                );\n                \n                CREATE TABLE skill_tiers (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT UNIQUE NOT NULL,\n                    description TEXT\n                );\n                \n                CREATE TABLE employees (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    email TEXT UNIQUE,\n                    phone TEXT,\n                    skill_tier_id INTEGER,\n                    FOREIGN KEY (skill_tier_id) REFERENCES skill_tiers(id)\n                );\n                \n                CREATE TABLE evaluations (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    employee_id INTEGER NOT NULL,\n                    date TEXT NOT NULL,\n                    score REAL NOT NULL,\n                    FOREIGN KEY (employee_id) REFERENCES employees(id)\n                );\n            ''')\n        \n        # Create database migration manager (simplified mock for testing)\n        class MockMigrationManager:\n            def migrate_data(self, old_config, new_config):\n                # Connect to old database\n                with closing(sqlite3.connect(old_config['path'])) as old_conn:\n                    old_conn.row_factory = sqlite3.Row\n                    \n                    # Connect to new database\n                    with closing(sqlite3.connect(new_config['path'])) as new_conn:\n                        # Migrate users\n                        users = old_conn.execute("SELECT * FROM users").fetchall()\n                        for user in users:\n                            new_conn.execute(\n                                "INSERT INTO users (username, password_hash, salt, email, is_admin) VALUES (?, ?, ?, ?, ?)",\n                                (user['username'], user['password_hash'], user['salt'], user['email'], user['is_admin'])\n                            )\n                        \n                        # Migrate skill tiers\n                        tiers = old_conn.execute("SELECT * FROM skill_tiers").fetchall()\n                        for tier in tiers:\n                            new_conn.execute(\n                                "INSERT INTO skill_tiers (name, description) VALUES (?, ?)",\n                                (tier['name'], tier['description'])\n                            )\n                        \n                        new_conn.commit()\n                return True\n        \n        # Test migration\n        old_config = {'type': 'sqlite', 'path': old_db_path}\n        new_config = {'type': 'sqlite', 'path': new_db_path}\n        \n        migration_manager = MockMigrationManager()\n        assert migration_manager.migrate_data(old_config, new_config)\n        \n        # Verify migration results\n        with closing(sqlite3.connect(new_db_path)) as conn:\n            conn.row_factory = sqlite3.Row\n            \n            # Verify users were migrated\n            users = conn.execute("SELECT * FROM users").fetchall()\n            assert len(users) == 1\n            assert users[0]['username'] == 'admin'\n            \n            # Verify skill tiers were migrated\n            tiers = conn.execute("SELECT * FROM skill_tiers").fetchall()\n            assert len(tiers) == 3\n            \n            # Verify new tables exist\n            tables = conn.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()\n            table_names = [table['name'] for table in tables]\n            assert 'employees' in table_names\n            assert 'evaluations' in table_names\n    \n    def test_configuration_validation(self, temp_directory):\n        """Test database configuration validation."""\n        # Invalid configurations to test\n        invalid_configs = [\n            # Missing type\n            {'path': os.path.join(temp_directory, 'test.db')},\n            \n            # Invalid type\n            {'type': 'unknown', 'path': os.path.join(temp_directory, 'test.db')},\n            \n            # SQLite missing path\n            {'type': 'sqlite'},\n            \n            # MySQL missing required fields\n            {'type': 'mysql', 'host': 'localhost'},\n            \n            # PostgreSQL missing required fields\n            {'type': 'postgresql', 'host': 'localhost', 'user': 'postgres'}\n        ]\n        \n        # Valid configurations to test\n        valid_configs = [\n            # SQLite with path\n            {'type': 'sqlite', 'path': os.path.join(temp_directory, 'test.db')},\n            \n            # MySQL with all required fields\n            {\n                'type': 'mysql',\n                'host': 'localhost',\n                'port': 3306,\n                'database': 'test_db',\n                'user': 'test_user',\n                'password': 'test_password'\n            },\n            \n            # PostgreSQL with all required fields\n            {\n                'type': 'postgresql',\n                'host': 'localhost',\n                'port': 5432,\n                'database': 'test_db',\n                'user': 'test_user',\n                'password': 'test_password'\n            }\n        ]\n        \n        # Create initializer\n        initializer = DatabaseInitializer(schema_dir=temp_directory)\n        \n        # Test invalid configurations\n        for config in invalid_configs:\n            status, error = initializer.validate_config(config)\n            assert not status, f"Invalid config was accepted: {config}"\n            assert error, "No error message provided for invalid config"\n        \n        # Test valid configurations\n        for config in valid_configs:\n            status, error = initializer.validate_config(config)\n            assert status, f"Valid config was rejected: {config}, Error: {error}"\n    \n    def test_cross_database_adapter_compatibility(self, temp_directory, sample_schema_dir):\n        """Test compatibility of adapters across different database types."""\n        # Create database paths\n        sqlite_path = os.path.join(temp_directory, 'sqlite.db')\n        \n        # Create configurations\n        sqlite_config = {'type': 'sqlite', 'path': sqlite_path}\n        mysql_config = {\n            'type': 'mysql',\n            'host': 'localhost',\n            'port': 3306,\n            'database': 'test_handyman',\n            'user': 'test_user',\n            'password': 'test_password'\n        }\n        postgresql_config = {\n            'type': 'postgresql',\n            'host': 'localhost',\n            'port': 5432,\n            'database': 'test_handyman',\n            'user': 'test_user',\n            'password': 'test_password'\n        }\n        \n        # Get adapters\n        sqlite_adapter = get_adapter(sqlite_config)\n        assert sqlite_adapter is not None\n        \n        # Test adapter-specific schema paths\n        sqlite_schema = sqlite_adapter.get_schema_path(sample_schema_dir)\n        assert sqlite_schema.endswith('schema_sqlite.sql')\n        \n        # Test compatibility checking\n        assert sqlite_adapter.is_compatible_with(sqlite_config)\n        assert not sqlite_adapter.is_compatible_with(mysql_config)\n        assert not sqlite_adapter.is_compatible_with(postgresql_config)\n        \n        # Initialize SQLite database\n        initializer = DatabaseInitializer(schema_dir=sample_schema_dir)\n        assert initializer.initialize_database(sqlite_config)\n        \n        # Test schema compatibility\n        schema_compatible = initializer.is_schema_compatible(sqlite_config)\n        assert schema_compatible, "Schema should be compatible with SQLite"\n\n\n# Skip this test class if MySQL is not available\n@pytest.mark.skipif(not local_mysql_is_available(), reason="MySQL not available for migration testing")\nclass TestMySQLMigration:\n    """Test MySQL migration scenarios."""\n    \n    def test_mysql_migration(self, temp_directory, sample_schema_dir):\n        """Test migration from SQLite to MySQL."""\n        # This is a placeholder for a more complex test that would:\n        # 1. Set up a SQLite database with sample data\n        # 2. Set up a MySQL database with an updated schema\n        # 3. Perform a migration from SQLite to MySQL\n        # 4. Verify that all data was correctly migrated\n        \n        # In a real test, we would implement the actual migration logic\n        # and verify the results in detail\n        \n        # For now, just check that MySQL is actually available\n        import pymysql\n        try:\n            with pymysql.connect(\n                host='localhost',\n                port=3306,\n                user='root',\n                password='',\n                connect_timeout=2\n            ):\n                # MySQL is available, so this test should run\n                pass\n        except pymysql.Error:\n            pytest.skip("MySQL not available with default credentials")