"""\nUtility functions for integration testing of the installer components.\n\nThis module provides helper functions for creating test environments,\nmocking database connections, and validating integration behavior.\n"""\n\nimport os\nimport sys\nimport json\nimport socket\nimport tempfile\nimport subprocess\nfrom contextlib import closing\nfrom functools import lru_cache\n\n# Add the project root to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')))\n\n# Test environment constants\nTEST_ADMIN_USER = {\n    'username': 'admin',\n    'password': 'StrongPassword123!',\n    'email': 'admin@example.com'\n}\n\nTEST_EMPLOYEE_DATA = [\n    {\n        'name': 'John Smith',\n        'email': 'john.smith@example.com',\n        'phone': '555-123-4567',\n        'skill_tier': 'Craftsman'\n    },\n    {\n        'name': 'Jane Doe',\n        'email': 'jane.doe@example.com',\n        'phone': '555-987-6543',\n        'skill_tier': 'Master Craftsman'\n    },\n    {\n        'name': 'Mike Johnson',\n        'email': 'mike.johnson@example.com',\n        'phone': '555-456-7890',\n        'skill_tier': 'Apprentice'\n    }\n]\n\n\ndef is_port_in_use(port, host='localhost'):\n    """Check if a port is in use on the host."""\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        return s.connect_ex((host, port)) == 0\n\n\ndef find_free_port(start_port=10000, end_port=11000):\n    """Find a free port in the given range."""\n    for port in range(start_port, end_port):\n        if not is_port_in_use(port):\n            return port\n    raise RuntimeError(f"No free ports found in range {start_port}-{end_port}")\n\n\n@lru_cache(maxsize=None)\ndef local_mysql_is_available():\n    """Check if MySQL is available for testing."""\n    try:\n        import pymysql\n        with closing(pymysql.connect(\n            host='localhost',\n            port=3306,\n            user='root',\n            password='',\n            connect_timeout=2\n        )):\n            return True\n    except (ImportError, pymysql.Error):\n        return False\n\n\n@lru_cache(maxsize=None)\ndef local_postgresql_is_available():\n    """Check if PostgreSQL is available for testing."""\n    try:\n        import psycopg2\n        with closing(psycopg2.connect(\n            host='localhost',\n            port=5432,\n            user='postgres',\n            password='postgres',\n            connect_timeout=2\n        )):\n            return True\n    except (ImportError, psycopg2.Error):\n        return False\n\n\ndef create_test_configuration(config_path, database_type='sqlite', temp_dir=None):\n    """Create a test configuration file with the specified database type."""\n    if temp_dir is None:\n        temp_dir = tempfile.gettempdir()\n    \n    config = {\n        'version': '1.0.0',\n        'app_name': 'Handyman KPI System',\n        'installation_path': os.path.join(temp_dir, 'kpi_system'),\n        'admin_user': {\n            'username': TEST_ADMIN_USER['username'],\n            'email': TEST_ADMIN_USER['email']\n        }\n    }\n    \n    # Set database configuration based on type\n    if database_type == 'sqlite':\n        config['database'] = {\n            'type': 'sqlite',\n            'path': os.path.join(temp_dir, 'test_db.sqlite')\n        }\n    elif database_type == 'mysql':\n        config['database'] = {\n            'type': 'mysql',\n            'host': 'localhost',\n            'port': 3306,\n            'database': 'test_handyman',\n            'user': 'test_user',\n            'password': 'test_password'\n        }\n    elif database_type == 'postgresql':\n        config['database'] = {\n            'type': 'postgresql',\n            'host': 'localhost',\n            'port': 5432,\n            'database': 'test_handyman',\n            'user': 'test_user',\n            'password': 'test_password'\n        }\n    else:\n        raise ValueError(f"Unsupported database type: {database_type}")\n    \n    # Save the configuration\n    with open(config_path, 'w') as f:\n        json.dump(config, f, indent=4)\n    \n    return config\n\n\ndef copy_directory_structure(source_dir, dest_dir):\n    """Copy directory structure from source to destination."""\n    for root, dirs, files in os.walk(source_dir):\n        for dir_name in dirs:\n            src_path = os.path.join(root, dir_name)\n            rel_path = os.path.relpath(src_path, source_dir)\n            dest_path = os.path.join(dest_dir, rel_path)\n            os.makedirs(dest_path, exist_ok=True)\n\n\ndef validate_database_schema(connection, expected_tables):\n    """Validate that the database has the expected tables."""\n    if hasattr(connection, 'cursor'):\n        cursor = connection.cursor()\n    else:\n        cursor = connection\n    \n    # Get list of tables\n    if connection.__class__.__module__.startswith('sqlite'):\n        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")\n    elif connection.__class__.__module__.startswith('pymysql'):\n        cursor.execute("SHOW TABLES")\n    elif connection.__class__.__module__.startswith('psycopg2'):\n        cursor.execute("""\n            SELECT table_name \n            FROM information_schema.tables \n            WHERE table_schema='public'\n        """)\n    \n    tables = [row[0] for row in cursor.fetchall()]\n    \n    # Check if all expected tables exist\n    missing_tables = set(expected_tables) - set(tables)\n    if missing_tables:\n        return False, f"Missing tables: {', '.join(missing_tables)}"\n    \n    return True, "Schema validated successfully"