"""\nTest suite for database initializer.\n\nThis module contains comprehensive tests for the DatabaseInitializer class\nto ensure it correctly initializes databases using the appropriate adapter.\n"""\n\nimport os\nimport sys\nimport unittest\nimport tempfile\nimport shutil\nfrom unittest.mock import patch, MagicMock, mock_open\n\n# Add the main project directory to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../')))\n\n# Import the DatabaseInitializer class\nfrom installer.shared.database.initializer import DatabaseInitializer\n\n\nclass TestDatabaseInitializer(unittest.TestCase):\n    """Test DatabaseInitializer class."""\n    \n    def setUp(self):\n        """Set up test environment."""\n        # Create temporary directory for schema files\n        self.temp_dir = tempfile.mkdtemp()\n        \n        # Create schema files\n        self.sqlite_schema = "CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT);"\n        self.mysql_schema = "CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255));"\n        self.postgresql_schema = "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255));"\n        \n        with open(os.path.join(self.temp_dir, 'schema_sqlite.sql'), 'w') as f:\n            f.write(self.sqlite_schema)\n        \n        with open(os.path.join(self.temp_dir, 'schema_mysql.sql'), 'w') as f:\n            f.write(self.mysql_schema)\n        \n        with open(os.path.join(self.temp_dir, 'schema_postgresql.sql'), 'w') as f:\n            f.write(self.postgresql_schema)\n        \n        # Create initializer with test schema directory\n        self.initializer = DatabaseInitializer(schema_dir=self.temp_dir)\n        \n        # Common database configuration\n        self.sqlite_config = {'type': 'sqlite', 'path': 'test.db'}\n        self.mysql_config = {\n            'type': 'mysql',\n            'host': 'localhost',\n            'port': '3306',\n            'user': 'root',\n            'password': 'password',\n            'name': 'test_db'\n        }\n        self.postgresql_config = {\n            'type': 'postgresql',\n            'host': 'localhost',\n            'port': '5432',\n            'user': 'postgres',\n            'password': 'password',\n            'name': 'test_db'\n        }\n    \n    def tearDown(self):\n        """Clean up test environment."""\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)\n    \n    def test_initializer_creation(self):\n        """Test initializer creation."""\n        # Test with explicit schema directory\n        initializer = DatabaseInitializer(schema_dir=self.temp_dir)\n        self.assertEqual(initializer.schema_dir, self.temp_dir)\n        \n        # Test with default schema directory\n        with patch('os.path.dirname', return_value='/fake/path'):\n            initializer = DatabaseInitializer()\n            self.assertEqual(initializer.schema_dir, '/fake/path/..')\n    \n    def test_get_schema_path(self):\n        """Test getting schema file path."""\n        # Test valid database types\n        self.assertEqual(\n            self.initializer._get_schema_path('sqlite'),\n            os.path.join(self.temp_dir, 'schema_sqlite.sql')\n        )\n        \n        self.assertEqual(\n            self.initializer._get_schema_path('mysql'),\n            os.path.join(self.temp_dir, 'schema_mysql.sql')\n        )\n        \n        self.assertEqual(\n            self.initializer._get_schema_path('postgresql'),\n            os.path.join(self.temp_dir, 'schema_postgresql.sql')\n        )\n    \n    def test_read_schema(self):\n        """Test reading schema files."""\n        # Test reading SQLite schema\n        schema = self.initializer._read_schema('sqlite')\n        self.assertEqual(schema, self.sqlite_schema)\n        \n        # Test reading MySQL schema\n        schema = self.initializer._read_schema('mysql')\n        self.assertEqual(schema, self.mysql_schema)\n        \n        # Test reading PostgreSQL schema\n        schema = self.initializer._read_schema('postgresql')\n        self.assertEqual(schema, self.postgresql_schema)\n    \n    def test_read_schema_file_not_found(self):\n        """Test reading schema file that doesn't exist."""\n        # Test with non-existent schema file and no fallback\n        with self.assertRaises(FileNotFoundError):\n            # Remove the SQLite schema file\n            os.remove(os.path.join(self.temp_dir, 'schema_sqlite.sql'))\n            \n            # Attempt to read the schema (should fail)\n            self.initializer._read_schema('sqlite')\n    \n    def test_read_schema_with_fallback(self):\n        """Test reading schema file with fallback to SQLite schema."""\n        # Create initializer with custom schema directory\n        custom_dir = os.path.join(self.temp_dir, 'custom')\n        os.makedirs(custom_dir)\n        \n        # Create only SQLite schema in custom directory\n        with open(os.path.join(custom_dir, 'schema_sqlite.sql'), 'w') as f:\n            f.write(self.sqlite_schema)\n        \n        # Create initializer with custom schema directory\n        initializer = DatabaseInitializer(schema_dir=custom_dir)\n        \n        # Test reading MySQL schema (should fall back to SQLite)\n        with patch('logging.Logger.warning') as mock_warning:\n            schema = initializer._read_schema('mysql')\n            \n            # Verify warning was logged\n            mock_warning.assert_called_once()\n            self.assertIn('fallback', str(mock_warning.call_args))\n            \n            # Verify SQLite schema was returned as fallback\n            self.assertEqual(schema, self.sqlite_schema)