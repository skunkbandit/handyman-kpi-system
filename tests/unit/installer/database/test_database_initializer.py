"""\nTest suite for database initializer.\n\nThis module contains comprehensive tests for the DatabaseInitializer class\nto ensure it correctly initializes databases using the appropriate adapter.\n"""\n\nimport os\nimport sys\nimport unittest\nimport tempfile\nimport shutil\nfrom unittest.mock import patch, MagicMock, mock_open\n\n# Add the main project directory to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../')))\n\n# Import the DatabaseInitializer class\nfrom installer.shared.database.initializer import DatabaseInitializer\n\n\nclass TestDatabaseInitializer(unittest.TestCase):\n    """Test DatabaseInitializer class."""\n    \n    def setUp(self):\n        """Set up test environment."""\n        # Create temporary directory for schema files\n        self.temp_dir = tempfile.mkdtemp()\n        \n        # Create schema files\n        self.sqlite_schema = "CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT);"\n        self.mysql_schema = "CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255));"\n        self.postgresql_schema = "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255));"\n        \n        with open(os.path.join(self.temp_dir, 'schema_sqlite.sql'), 'w') as f:\n            f.write(self.sqlite_schema)\n        \n        with open(os.path.join(self.temp_dir, 'schema_mysql.sql'), 'w') as f:\n            f.write(self.mysql_schema)\n        \n        with open(os.path.join(self.temp_dir, 'schema_postgresql.sql'), 'w') as f:\n            f.write(self.postgresql_schema)\n        \n        # Create initializer with test schema directory\n        self.initializer = DatabaseInitializer(schema_dir=self.temp_dir)\n        \n        # Common database configuration\n        self.sqlite_config = {'type': 'sqlite', 'path': 'test.db'}\n        self.mysql_config = {\n            'type': 'mysql',\n            'host': 'localhost',\n            'port': '3306',\n            'user': 'root',\n            'password': 'password',\n            'name': 'test_db'\n        }\n        self.postgresql_config = {\n            'type': 'postgresql',\n            'host': 'localhost',\n            'port': '5432',\n            'user': 'postgres',\n            'password': 'password',\n            'name': 'test_db'\n        }\n    \n    def tearDown(self):\n        """Clean up test environment."""\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)\n    \n    def test_initializer_creation(self):\n        """Test initializer creation."""\n        # Test with explicit schema directory\n        initializer = DatabaseInitializer(schema_dir=self.temp_dir)\n        self.assertEqual(initializer.schema_dir, self.temp_dir)\n        \n        # Test with default schema directory\n        with patch('os.path.dirname', return_value='/fake/path'):\n            initializer = DatabaseInitializer()\n            self.assertEqual(initializer.schema_dir, '/fake/path/..')\n    \n    def test_get_schema_path(self):\n        """Test getting schema file path."""\n        # Test valid database types\n        self.assertEqual(\n            self.initializer._get_schema_path('sqlite'),\n            os.path.join(self.temp_dir, 'schema_sqlite.sql')\n        )\n        \n        self.assertEqual(\n            self.initializer._get_schema_path('mysql'),\n            os.path.join(self.temp_dir, 'schema_mysql.sql')\n        )\n        \n        self.assertEqual(\n            self.initializer._get_schema_path('postgresql'),\n            os.path.join(self.temp_dir, 'schema_postgresql.sql')\n        )\n    \n    def test_read_schema(self):\n        """Test reading schema files."""\n        # Test reading SQLite schema\n        schema = self.initializer._read_schema('sqlite')\n        self.assertEqual(schema, self.sqlite_schema)\n        \n        # Test reading MySQL schema\n        schema = self.initializer._read_schema('mysql')\n        self.assertEqual(schema, self.mysql_schema)\n        \n        # Test reading PostgreSQL schema\n        schema = self.initializer._read_schema('postgresql')\n        self.assertEqual(schema, self.postgresql_schema)\n    \n    def test_read_schema_file_not_found(self):\n        """Test reading schema file that doesn't exist."""\n        # Test with non-existent schema file and no fallback\n        with self.assertRaises(FileNotFoundError):\n            # Remove the SQLite schema file\n            os.remove(os.path.join(self.temp_dir, 'schema_sqlite.sql'))\n            \n            # Attempt to read the schema (should fail)\n            self.initializer._read_schema('sqlite')\n    \n    def test_read_schema_with_fallback(self):\n        """Test reading schema file with fallback to SQLite schema."""\n        # Create initializer with custom schema directory\n        custom_dir = os.path.join(self.temp_dir, 'custom')\n        os.makedirs(custom_dir)\n        \n        # Create only SQLite schema in custom directory\n        with open(os.path.join(custom_dir, 'schema_sqlite.sql'), 'w') as f:\n            f.write(self.sqlite_schema)\n        \n        # Create initializer with custom schema directory\n        initializer = DatabaseInitializer(schema_dir=custom_dir)\n        \n        # Test reading MySQL schema (should fall back to SQLite)\n        with patch('logging.Logger.warning') as mock_warning:\n            schema = initializer._read_schema('mysql')\n            \n            # Verify warning was logged\n            mock_warning.assert_called_once()\n            self.assertIn('fallback', str(mock_warning.call_args))\n            \n            # Verify SQLite schema was returned as fallback\n            self.assertEqual(schema, self.sqlite_schema)\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_test_database_connection(self, mock_get_adapter):\n        """Test testing database connection."""\n        # Set up mock adapter\n        mock_adapter = MagicMock()\n        mock_adapter.test_connection.return_value = True\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Test connection (should succeed)\n        success, error = self.initializer.test_database_connection(self.sqlite_config)\n        self.assertTrue(success)\n        self.assertEqual(error, "")\n        \n        # Verify adapter was created with correct type\n        mock_get_adapter.assert_called_with('sqlite', self.sqlite_config)\n        \n        # Verify test_connection was called\n        mock_adapter.test_connection.assert_called_once()\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_test_database_connection_failure(self, mock_get_adapter):\n        """Test testing database connection failure."""\n        # Set up mock adapter that fails connection test\n        mock_adapter = MagicMock()\n        mock_adapter.test_connection.return_value = False\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Test connection (should fail)\n        success, error = self.initializer.test_database_connection(self.sqlite_config)\n        self.assertFalse(success)\n        self.assertEqual(error, "Connection test failed")\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_test_database_connection_exception(self, mock_get_adapter):\n        """Test testing database connection with exception."""\n        # Set up mock get_adapter to raise exception\n        mock_get_adapter.side_effect = ValueError("Unsupported database type")\n        \n        # Test connection (should fail)\n        success, error = self.initializer.test_database_connection(self.sqlite_config)\n        self.assertFalse(success)\n        self.assertEqual(error, "Unsupported database type")\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_initialize_database(self, mock_get_adapter):\n        """Test initializing database."""\n        # Set up mock adapter\n        mock_adapter = MagicMock()\n        mock_adapter.initialize.return_value = True\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Initialize database (should succeed)\n        self.assertTrue(self.initializer.initialize_database(self.sqlite_config))\n        \n        # Verify adapter was created with correct type\n        mock_get_adapter.assert_called_with('sqlite', self.sqlite_config)\n        \n        # Verify initialize was called with correct schema\n        mock_adapter.initialize.assert_called_once()\n        schema = mock_adapter.initialize.call_args[0][0]\n        self.assertEqual(schema, self.sqlite_schema)\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_initialize_database_failure(self, mock_get_adapter):\n        """Test initializing database failure."""\n        # Set up mock adapter that fails initialization\n        mock_adapter = MagicMock()\n        mock_adapter.initialize.return_value = False\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Initialize database (should fail)\n        self.assertFalse(self.initializer.initialize_database(self.sqlite_config))\n        \n        # Verify initialize was called\n        mock_adapter.initialize.assert_called_once()\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_initialize_database_exception(self, mock_get_adapter):\n        """Test initializing database with exception."""\n        # Set up mock get_adapter to raise exception\n        mock_get_adapter.side_effect = ValueError("Unsupported database type")\n        \n        # Initialize database (should fail)\n        self.assertFalse(self.initializer.initialize_database(self.sqlite_config))\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_create_admin_user(self, mock_get_adapter):\n        """Test creating admin user."""\n        # Set up mock adapter\n        mock_adapter = MagicMock()\n        mock_adapter.create_admin_user.return_value = True\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Create admin user (should succeed)\n        username = "admin"\n        password = "Password123"\n        email = "admin@example.com"\n        \n        self.assertTrue(self.initializer.create_admin_user(\n            username, password, email, self.sqlite_config\n        ))\n        \n        # Verify adapter was created with correct type\n        mock_get_adapter.assert_called_with('sqlite', self.sqlite_config)\n        \n        # Verify create_admin_user was called with correct parameters\n        mock_adapter.create_admin_user.assert_called_with(username, password, email)\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_create_admin_user_failure(self, mock_get_adapter):\n        """Test creating admin user failure."""\n        # Set up mock adapter that fails user creation\n        mock_adapter = MagicMock()\n        mock_adapter.create_admin_user.return_value = False\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Create admin user (should fail)\n        self.assertFalse(self.initializer.create_admin_user(\n            "admin", "password", "admin@example.com", self.sqlite_config\n        ))\n        \n        # Verify create_admin_user was called\n        mock_adapter.create_admin_user.assert_called_once()\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_create_admin_user_exception(self, mock_get_adapter):\n        """Test creating admin user with exception."""\n        # Set up mock get_adapter to raise exception\n        mock_get_adapter.side_effect = ValueError("Unsupported database type")\n        \n        # Create admin user (should fail)\n        self.assertFalse(self.initializer.create_admin_user(\n            "admin", "password", "admin@example.com", self.sqlite_config\n        ))\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_get_database_info(self, mock_get_adapter):\n        """Test getting database information."""\n        # Set up mock adapter\n        mock_adapter = MagicMock()\n        expected_info = {\n            'type': 'sqlite',\n            'version': '3.36.0',\n            'path': 'test.db',\n            'size_bytes': 4096,\n            'table_count': 1,\n            'tables': {'users': {'row_count': 1}}\n        }\n        mock_adapter.get_database_info.return_value = expected_info\n        mock_get_adapter.return_value = mock_adapter\n        \n        # Get database info\n        info = self.initializer.get_database_info(self.sqlite_config)\n        \n        # Verify adapter was created with correct type\n        mock_get_adapter.assert_called_with('sqlite', self.sqlite_config)\n        \n        # Verify get_database_info was called\n        mock_adapter.get_database_info.assert_called_once()\n        \n        # Verify returned info matches expected info\n        self.assertEqual(info, expected_info)\n    \n    @patch('installer.shared.database.initializer.get_adapter')\n    def test_get_database_info_exception(self, mock_get_adapter):\n        """Test getting database information with exception."""\n        # Set up mock get_adapter to raise exception\n        mock_get_adapter.side_effect = ValueError("Unsupported database type")\n        \n        # Get database info (should return error info)\n        info = self.initializer.get_database_info(self.sqlite_config)\n        \n        self.assertEqual(info['type'], 'sqlite')\n        self.assertIn('error', info)\n        self.assertEqual(info['error'], "Unsupported database type")\n    \n    def test_integration_with_sqlite(self):\n        """Integration test with SQLite adapter."""\n        # Use a real SQLite database for this test\n        db_path = os.path.join(self.temp_dir, 'integration_test.db')\n        config = {'type': 'sqlite', 'path': db_path}\n        \n        # Test connection\n        success, error = self.initializer.test_database_connection(config)\n        self.assertTrue(success, f"Connection test failed: {error}")\n        \n        # Initialize database\n        self.assertTrue(self.initializer.initialize_database(config))\n        \n        # Create admin user\n        self.assertTrue(self.initializer.create_admin_user(\n            "admin", "Password123", "admin@example.com", config\n        ))\n        \n        # Get database info\n        info = self.initializer.get_database_info(config)\n        \n        # Verify information\n        self.assertEqual(info['type'], 'sqlite')\n        self.assertIn('version', info)\n        self.assertEqual(info['path'], db_path)\n        self.assertIn('size_bytes', info)\n        self.assertEqual(info['table_count'], 1)\n        self.assertIn('users', info['tables'])\n        self.assertEqual(info['tables']['users']['row_count'], 1)\n\n\nif __name__ == '__main__':\n    unittest.main()