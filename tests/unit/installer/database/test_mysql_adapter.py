"""\nTest suite for MySQL database adapter.\n\nThis module contains comprehensive tests for the MySQL database adapter\nwith mocking to avoid requiring an actual MySQL server for testing.\n"""\n\nimport os\nimport sys\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n# Add the main project directory to the path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../')))\n\n# Import the get_adapter function\nfrom installer.shared.database.adapters import get_adapter\n\n\nclass TestMySQLAdapter(unittest.TestCase):\n    """Test MySQL database adapter with mocking."""\n    \n    def setUp(self):\n        """Set up test environment."""\n        # MySQL configuration\n        self.config = {\n            'host': 'localhost',\n            'port': '3306',\n            'user': 'root',\n            'password': 'password',\n            'name': 'test_handyman_kpi'\n        }\n        \n        # Simple schema for testing\n        self.schema = """\n        CREATE TABLE users (\n            id INT AUTO_INCREMENT PRIMARY KEY,\n            username VARCHAR(255) UNIQUE NOT NULL,\n            password_hash VARCHAR(255) NOT NULL,\n            salt VARCHAR(255) NOT NULL,\n            email VARCHAR(255),\n            is_admin TINYINT DEFAULT 0\n        );\n        """\n        \n        # Patch mysql.connector to avoid requiring an actual MySQL server\n        self.mysql_patcher = patch('installer.shared.database.adapters.mysql.mysql')\n        self.mock_mysql = self.mysql_patcher.start()\n        \n        # Set up the mock connector\n        self.mock_connection = MagicMock()\n        self.mock_cursor = MagicMock()\n        self.mock_connection.cursor.return_value = self.mock_cursor\n        self.mock_mysql.connector.connect.return_value = self.mock_connection\n        \n        # Successful connection test result\n        self.mock_cursor.fetchone.return_value = (1,)\n        \n        # Create adapter\n        self.adapter = get_adapter('mysql', self.config)\n    \n    def tearDown(self):\n        """Clean up test environment."""\n        self.mysql_patcher.stop()\n    \n    def test_adapter_creation(self):\n        """Test adapter creation."""\n        # Test with valid configuration\n        adapter = get_adapter('mysql', self.config)\n        self.assertIsNotNone(adapter)\n        self.assertEqual(adapter.host, self.config['host'])\n        self.assertEqual(adapter.port, int(self.config['port']))\n        self.assertEqual(adapter.user, self.config['user'])\n        self.assertEqual(adapter.password, self.config['password'])\n        self.assertEqual(adapter.database, self.config['name'])\n        \n        # Test with default configuration\n        adapter = get_adapter('mysql', {})\n        self.assertIsNotNone(adapter)\n        self.assertEqual(adapter.host, 'localhost')\n        self.assertEqual(adapter.port, 3306)\n        self.assertEqual(adapter.user, 'root')\n        self.assertEqual(adapter.password, '')\n        self.assertEqual(adapter.database, 'handyman_kpi')\n    \n    def test_connection(self):\n        """Test database connection."""\n        # Test connection with valid configuration\n        self.assertTrue(self.adapter.test_connection())\n        \n        # Verify mock was called with correct parameters\n        self.mock_mysql.connector.connect.assert_called_with(\n            host='localhost',\n            port=3306,\n            user='root',\n            password='password'\n        )\n        \n        # Verify SELECT 1 was executed\n        self.mock_cursor.execute.assert_called_with("SELECT 1")\n    \n    def test_connection_failure(self):\n        """Test connection failure scenarios."""\n        # Make connection fail\n        self.mock_mysql.connector.connect.side_effect = self.mock_mysql.connector.Error("Test error")\n        \n        # Test connection (should fail)\n        self.assertFalse(self.adapter.test_connection())\n        \n        # Reset side effect\n        self.mock_mysql.connector.connect.side_effect = None\n        \n        # Make query fail\n        self.mock_cursor.execute.side_effect = self.mock_mysql.connector.Error("Test error")\n        \n        # Test connection (should fail)\n        self.assertFalse(self.adapter.test_connection())\n        \n        # Reset side effect\n        self.mock_cursor.execute.side_effect = None\n        \n        # Make fetchone return invalid result\n        self.mock_cursor.fetchone.return_value = (0,)\n        \n        # Test connection (should fail)\n        self.assertFalse(self.adapter.test_connection())\n    \n    def test_missing_mysql_connector(self):\n        """Test behavior when mysql-connector-python is not installed."""\n        # Stop current patcher\n        self.mysql_patcher.stop()\n        \n        # Create new patcher that simulates ImportError\n        import_error_patcher = patch('installer.shared.database.adapters.mysql.mysql.connector', None)\n        import_error_patcher.start()\n        \n        try:\n            # Accessing mysql.connector should raise ImportError\n            with patch('installer.shared.database.adapters.mysql.mysql_connector_missing', \n                      side_effect=ImportError("Test import error")):\n                # Create adapter (should work, but operations will fail)\n                adapter = get_adapter('mysql', self.config)\n                \n                # Operations should fail gracefully\n                self.assertFalse(adapter.test_connection())\n                self.assertFalse(adapter.initialize(self.schema))\n                self.assertFalse(adapter.create_admin_user("admin", "password", "admin@example.com"))\n                \n                # get_database_info should return error information\n                info = adapter.get_database_info()\n                self.assertEqual(info['type'], 'mysql')\n                self.assertIn('error', info)\n                self.assertIn('not installed', info['error'])\n        \n        finally:\n            # Stop the import error patcher\n            import_error_patcher.stop()\n            \n            # Restart the original patcher\n            self.mysql_patcher = patch('installer.shared.database.adapters.mysql.mysql')\n            self.mock_mysql = self.mysql_patcher.start()\n            self.mock_connection = MagicMock()\n            self.mock_cursor = MagicMock()\n            self.mock_connection.cursor.return_value = self.mock_cursor\n            self.mock_mysql.connector.connect.return_value = self.mock_connection\n            self.mock_cursor.fetchone.return_value = (1,)\n            \n            # Recreate adapter\n            self.adapter = get_adapter('mysql', self.config)\n    \n    def test_initialization(self):\n        """Test database initialization."""\n        # Set up expected behavior\n        self.mock_cursor.execute.return_value = None\n        \n        # Initialize database\n        self.assertTrue(self.adapter.initialize(self.schema))\n        \n        # Verify connection was made twice (first to create database, then to use it)\n        self.assertEqual(self.mock_mysql.connector.connect.call_count, 2)\n        \n        # Verify CREATE DATABASE was executed\n        create_db_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                         if "CREATE DATABASE" in str(call)]\n        self.assertTrue(any(create_db_calls))\n        \n        # Verify schema statement was executed\n        schema_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                       if "CREATE TABLE" in str(call)]\n        self.assertTrue(any(schema_calls))\n    \n    def test_initialization_failure(self):\n        """Test initialization failure scenarios."""\n        # Make first connection fail\n        self.mock_mysql.connector.connect.side_effect = [\n            self.mock_mysql.connector.Error("Test error"),\n            self.mock_connection\n        ]\n        \n        # Test initialization (should fail)\n        self.assertFalse(self.adapter.initialize(self.schema))\n        \n        # Reset side effect\n        self.mock_mysql.connector.connect.side_effect = None\n        \n        # Make CREATE DATABASE fail\n        self.mock_cursor.execute.side_effect = self.mock_mysql.connector.Error("Test error")\n        \n        # Test initialization (should fail)\n        self.assertFalse(self.adapter.initialize(self.schema))\n    \n    def test_admin_user_creation(self):\n        """Test admin user creation."""\n        # Setup for users table exists check\n        self.mock_cursor.fetchone.side_effect = [\n            ("users",),  # SHOW TABLES LIKE 'users'\n            None,        # SELECT id FROM users WHERE username = %s\n            (1,)         # Other fetchone calls\n        ]\n        \n        # Create admin user\n        username = "admin"\n        password = "Password123"\n        email = "admin@example.com"\n        \n        self.assertTrue(self.adapter.create_admin_user(username, password, email))\n        \n        # Verify table check was performed\n        table_check_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                           if "SHOW TABLES LIKE" in str(call)]\n        self.assertTrue(any(table_check_calls))\n        \n        # Verify user check was performed\n        user_check_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                          if "SELECT id FROM users WHERE username" in str(call)]\n        self.assertTrue(any(user_check_calls))\n        \n        # Verify INSERT was performed\n        insert_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                      if "INSERT INTO users" in str(call)]\n        self.assertTrue(any(insert_calls))\n    \n    def test_admin_user_update(self):\n        """Test admin user update if already exists."""\n        # Setup for users table exists check and user exists\n        self.mock_cursor.fetchone.side_effect = [\n            ("users",),  # SHOW TABLES LIKE 'users'\n            (1,),        # SELECT id FROM users WHERE username = %s (user exists)\n            (1,)         # Other fetchone calls\n        ]\n        \n        # Create/update admin user\n        username = "admin"\n        password = "NewPassword456"\n        email = "admin@example.com"\n        \n        self.assertTrue(self.adapter.create_admin_user(username, password, email))\n        \n        # Verify UPDATE was performed instead of INSERT\n        update_calls = [call for call, _ in self.mock_cursor.execute.call_args_list \n                      if "UPDATE users SET" in str(call)]\n        self.assertTrue(any(update_calls))\n    \n    def test_admin_user_with_missing_table(self):\n        """Test admin user creation with missing users table."""\n        # Setup for users table missing\n        self.mock_cursor.fetchone.side_effect = [\n            None,  # SHOW TABLES LIKE 'users'\n            (1,)   # Other fetchone calls\n        ]\n        \n        # Attempt to create admin user without users table\n        self.assertFalse(self.adapter.create_admin_user("admin", "password", "admin@example.com"))\n    \n    def test_admin_user_creation_error(self):\n        """Test admin user creation error handling."""\n        # Setup for table check success but execution failure\n        self.mock_cursor.fetchone.side_effect = [\n            ("users",),  # SHOW TABLES LIKE 'users'\n            None,        # SELECT id FROM users WHERE username = %s\n            (1,)         # Other fetchone calls\n        ]\n        \n        # Make execute throw error on INSERT\n        def side_effect(query, *args, **kwargs):\n            if "INSERT INTO users" in query:\n                raise self.mock_mysql.connector.Error("Test error")\n            return MagicMock()\n        \n        self.mock_cursor.execute.side_effect = side_effect\n        \n        # Attempt to create admin user (should fail)\n        self.assertFalse(self.adapter.create_admin_user("admin", "password", "admin@example.com"))\n    \n    def test_password_hashing(self):\n        """Test password hashing."""\n        password = "TestPassword123"\n        salt = "0123456789abcdef"\n        \n        # Hash password\n        password_hash = self.adapter._hash_password(password, salt)\n        \n        # Verify hash is not empty and is a hex string\n        self.assertTrue(password_hash)\n        self.assertTrue(all(c in '0123456789abcdef' for c in password_hash))\n        \n        # Same password and salt should produce same hash\n        password_hash2 = self.adapter._hash_password(password, salt)\n        self.assertEqual(password_hash, password_hash2)\n        \n        # Different password should produce different hash\n        password_hash3 = self.adapter._hash_password("DifferentPassword", salt)\n        self.assertNotEqual(password_hash, password_hash3)\n        \n        # Different salt should produce different hash\n        password_hash4 = self.adapter._hash_password(password, "fedcba9876543210")\n        self.assertNotEqual(password_hash, password_hash4)\n    \n    def test_get_database_info(self):\n        """Test getting database information."""\n        # Setup mock cursor for database info queries\n        version_query = "SELECT VERSION()"\n        table_count_query = "SELECT COUNT(*)"\n        db_size_query = "SELECT SUM(data_length + index_length)"\n        tables_query = "SELECT table_name, table_rows"\n        \n        expected_version = "8.0.28"\n        expected_table_count = 1\n        expected_db_size = 4096\n        expected_tables = [("users", 1)]\n        \n        def side_effect(query, *args, **kwargs):\n            if version_query in query:\n                self.mock_cursor.fetchone.return_value = (expected_version,)\n            elif table_count_query in query:\n                self.mock_cursor.fetchone.return_value = (expected_table_count,)\n            elif db_size_query in query:\n                self.mock_cursor.fetchone.return_value = (expected_db_size,)\n            elif tables_query in query:\n                self.mock_cursor.fetchall.return_value = expected_tables\n            return None\n        \n        self.mock_cursor.execute.side_effect = side_effect\n        \n        # Get database info\n        info = self.adapter.get_database_info()\n        \n        # Verify information\n        self.assertEqual(info['type'], 'mysql')\n        self.assertEqual(info['version'], expected_version)\n        self.assertEqual(info['host'], self.config['host'])\n        self.assertEqual(info['port'], int(self.config['port']))\n        self.assertEqual(info['database'], self.config['name'])\n        self.assertEqual(info['size_bytes'], expected_db_size)\n        self.assertEqual(info['table_count'], expected_table_count)\n        self.assertIn('users', info['tables'])\n        self.assertEqual(info['tables']['users']['row_count'], 1)\n    \n    def test_get_database_info_with_error(self):\n        """Test getting database information with error."""\n        # Make connection raise exception\n        self.mock_mysql.connector.connect.side_effect = self.mock_mysql.connector.Error("Test error")\n        \n        # Get database info (should return error info)\n        info = self.adapter.get_database_info()\n        self.assertEqual(info['type'], 'mysql')\n        self.assertIn('host', info)\n        self.assertIn('error', info)\n        self.assertIn('Test error', info['error'])\n\n\nif __name__ == '__main__':\n    unittest.main()